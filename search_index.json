[
["index.html", "Community contributions for EDAV Fall 2019 Chapter 1 Instructions 1.1 Background 1.2 Preparing your .Rmd file 1.3 Submission Steps 1.4 Optional tweaks 1.5 FAQ", " Community contributions for EDAV Fall 2019 2019-10-28 Chapter 1 Instructions This chapter gives you all the information you need to upload your community contribution. Please read this entire document carefully before making your submission. Of particular note is the fact that bookdown requires a different .Rmd format than you’re used to, so you must make changes to the beginning of the file as described below before submitting. 1.1 Background This web site makes use of the bookdown package to render a collection of .Rmd files into a nicely formatted online book with chapters and subchapters. Your job will be to submit a slightly modified version of your community contribution .Rmd file to the GitHub repository where the source files for this web site are stored. On the backend, the admins will divide the chapters into book sections and order them. We use Travis CI to render the book and push the rendered .html files to our gh-pages branch–you can view our builds here–and GitHub Pages to host the site. If your community contribution is in a different format, then create a short .Rmd file that explains what you did, and includes links to any relevant files, such as slides, etc. which you can post on your GitHub repo (or another online site.) 1.2 Preparing your .Rmd file You should only submit ONE Rmd file. After completing these modifications, your .Rmd should look like this sample bookdown .Rmd. Create a concise, descriptive name for your project. For instance, name it base_r_ggplot_graph or something similar if your work is about contrasting/working with base R graphics and ggplot2 graphics. Check the .Rmd filenames in the project repo to make sure your name isn’t already taken. Your project name should be words only and joined with underscores, i.e. Do not include whitespace in the name. Create a copy of your .Rmd file with the new name. Completely delete the YAML header (the section at the top of the .Rmd that includes name, title, date, output, etc.) including the --- line. The first line should be a single hashtag (#) followed by your project name (this does not have to be exact same as the project folder name and may include white space), and it should be followed with one whitespace, otherwise bookdown will not render it as a header. Do not use single # headers anywhere else in the document. The second line should be blank, followed by your name(s): # Base R graphics vs. ggplot2 graphics Aaron Burr and Alexander Hamilton Your content starts here. If your project requires data, please use a built-in dataset or read directly from a URL, such as: df &lt;- readr::read_csv(&quot;https://people.sc.fsu.edu/~jburkardt/data/csv/addresses.csv&quot;) If you absolutely must include a data file, please use a small one, as for many reasons it is desirable to keep the repository size as small as possible. Want to get fancy? See the optional tweaks section below. 1.3 Submission Steps To submit your work, we will be following the instructions in this tutorial, which are provided in abbreviated form below, with specific instructions on naming conventions, content information, and other important details. Fork cc19 repo (this repo) to your GitHub account. Clone/download the forked repo to your local computer. Create a new branch and name it with your project name, in our case sample_project. If you forget to do so, check this tutorial to fix. Copy your modified .Rmd file with the same name into the root directory on the branch. In our example, it is sample_project.Rmd. Do not include an .html file. (In order for the bookdown package to work, all .Rmd files will be rendered behind the scenes.) [OPTIONAL] If you have other resources (such as images) included in your project, create a folder under resources/. In our example, it is resources/sample_project/. Put the resources files there. When you are ready to submit your project, push your branch to your remote repo. Follow this tutorial to create a pull request. If you follow the steps, we will merge it to the master branch. After submitting your pull request, do not be concerned if you see an “All builds have failed” message from Travis CI. There are things that need to be done on the backend, such as adding the libraries you use to the project for the Travis CI build to pass. 1.4 Optional tweaks If you prefer for links from your chapter to open in new tabs, add {target=&quot;_blank&quot;} after the link, such as: [edav.info](edav.info){target=&quot;_blank&quot;} Note that your headers (##, ###, etc.) will be converted to numbered headings as such: ## –&gt; 3.1 ### –&gt; 3.1.1 These headings will appear as chapter subheadings and sub-subheadings in the navigation panel on the left. Think about a logical structure for users to navigate your chapter. We recommend using only ## and ### headings as subheadings such as 4.1.3.4 are generally not necessary and look messy. Unfortunately, there’s no simple way to preview your chapter before it’s actually merged into the project. (bookdown has preview_chapter() option but it only works after the entire book has been rendered at least once and that will become more and more complex and require more and more packages as the project grows.) If you really want to preview it, fork and clone this minimal bookdown repo, add your .Rmd file, click the “Build book” button on the Build tab (next to Git), and then open any of the .html files in the _book folder in a web browser to see the rendered book. (Do not click the Knit button as it will not build a bookdown book.) If you’re interested in more bookdown options, see the official reference book. Have more useful tweaks to share? Submit an issue or PR. 1.5 FAQ 1.5.1 What should I expect after creating a pull request? Within a week after you create a pull request, we will apply a label to it and assign an administrater who will review all the files you submit to see if they meet the requirements. It will take some time before we can process all the pull requests, so as long as you see your pull request has been labeled and assigned to an administrater, don’t worry. However, if the admin contacts you regarding the pull request, that usually means your files fail to meet some requirements. The admin will clearly state what is wrong, so please fix them as soon as possible. 1.5.2 What if I catch mistakes after my pull request is merged? You may submit additional pull requests to fix material on the site. If the edits are small, such as fixing typos, it is easiest to make the edits directly on GitHub, following these instructions. We will merge first pull requests before edits, so please be patient. 1.5.3 Other questions If you encounter other problems, please submit an issue and we will look into it. Thank you for your contributions! "],
["sample-project.html", "Chapter 2 Sample Project", " Chapter 2 Sample Project Nancy Pelosi and Donald Trump This chapter gives a sample layout of your Rmd file. Test Photo "],
["intro-to-ridgeline-plot.html", "Chapter 3 Intro to Ridgeline Plot 3.1 Overview 3.2 tl;dr 3.3 Simple examples 3.4 Theory 3.5 External resources", " Chapter 3 Intro to Ridgeline Plot Hojin Lee and Hyuk Joon Kwon 3.1 Overview Ridgeline plot is a set of overlapped density plots, and it helps us to compare multiple distirbutions among dataset. Professor Claus O. Wilke from UT Austin, who created ggridges package, commented about ridgeline plot as below: “Ridgeline plots are partially overlapping line plots that create the impression of a mountain range. They can be quite useful for visualizing changes in distributions over time or space. These types of plots have also been called “joyplots”, in reference to the iconic cover art for Joy Division’s album Unknown Pleasures. However, given the unfortunate origin of the name Joy Division, the term “joyplot” is now discouraged.&quot; In this section, we will discuss how to create ridgeline plots using the ggplot and ggridges libraries. 3.2 tl;dr For those who do not want to go through the documents, the below is the polished version of a ridgeline plot and the codes. library(ucidata) library(ggplot2) library(ggridges) library(viridis) library(plyr) library(nycflights13) weather$month &lt;- as.factor(weather$month) ggplot(weather, aes(x = temp, y = reorder(month, desc(month)), fill = factor(..quantile..))) + stat_density_ridges(quantiles = c(0.25,0.5,0.75) , quantile_lines = TRUE , geom = &quot;density_ridges_gradient&quot; , alpha = 0.6 , scale = 2.3) + scale_fill_viridis(discrete = TRUE , name = &quot;Quantile&quot; , alpha = 0.3 , option = &quot;cividis&quot;) + ggtitle(&quot;What is the weather like in NYC?&quot;, subtitle = &quot;Ridgeline plot for NYC temperature by months&quot;) + xlab(&quot;Temperature (F)&quot;) + ylab(&quot;Months&quot;) + labs(caption = &quot;Source: nycflights13::weather&quot;) + theme(plot.title = element_text(face=&quot;bold&quot;)) + theme(plot.subtitle = element_text(face=&quot;bold&quot;, color=&quot;grey&quot;)) + theme(plot.caption=element_text(color=&quot;grey&quot;)) For more information about dataset, type ?nycflights13::weather into the console. 3.3 Simple examples For one who needs friendly step by step approach, please read the below. First, we need to install ggridges and ggplot2 packages. #install.packages(&quot;ggridges&quot;) #install.packages(&quot;ggplot2&quot;) Make sure that the y variable is a categorical variable, otherwise the function will throw an error. You can use y = as.factor(data) to transfrom your y variable into a categorical variable. data &lt;- forest_fires data$day &lt;- factor(data$day , levels= rev(c(&quot;sun&quot;, &quot;mon&quot;, &quot;tue&quot;, &quot;wed&quot;, &quot;thu&quot;, &quot;fri&quot;, &quot;sat&quot;))) ggplot(data, aes(x = DMC, y = day)) + geom_density_ridges() If you do not want the ridgeline plot to touch each other, please use the scale variable. A scale of 1.0 will make the adjust graph to barely touch each other. If the scale is greater than 1 the graphs will overlap with each other. Otherwise, if the scale is less than 1 the graphs will not touch each other. data &lt;- forest_fires data$day &lt;- factor(data$day , levels= rev(c(&quot;sun&quot;, &quot;mon&quot;, &quot;tue&quot;, &quot;wed&quot;, &quot;thu&quot;, &quot;fri&quot;, &quot;sat&quot;))) ggplot(data, aes(x = DMC, y = day)) + geom_density_ridges(scale = 1.1) There is a raindrop function within ridgeline plots, which combine the rideline plots with scatter plots; the function will plot scatter plot under the rideline plot. library(ISwR) data2 &lt;- red.cell.folate ggplot(data2, aes(x = folate, y = ventilation)) + stat_density_ridges(quantiles = c(0.25,0.5,0.75) , geom=&quot;density_ridges_gradient&quot; , jittered_points = TRUE , position = &quot;raincloud&quot; , alpha = 0.6 , scale = 0.6) Morevoer, it is possible to divide the data into quantiles and draw lines in between. This way, it would be easier for us to observe the median value and the interquartile range. data &lt;- forest_fires data$day &lt;- factor(data$day , levels= rev(c(&quot;sun&quot;, &quot;mon&quot;, &quot;tue&quot;, &quot;wed&quot;, &quot;thu&quot;, &quot;fri&quot;, &quot;sat&quot;))) ggplot(data, aes(x = temp, y = day, fill = factor(..quantile..))) + stat_density_ridges(quantiles = c(0.25,0.5,0.75) , quantile_lines =TRUE , geom=&quot;density_ridges_gradient&quot;) + scale_fill_viridis(discrete = TRUE , name = &quot;Quantile&quot; , option = &quot;plasma&quot;) In below, we have merged all the functions we have introduced, and here is the result! data2 &lt;- red.cell.folate ggplot(data2, aes(x = folate, y = ventilation, fill = factor(..quantile..))) + stat_density_ridges(quantiles = c(0.25,0.5,0.75) , quantile_lines = TRUE , geom=&quot;density_ridges_gradient&quot; , jittered_points = TRUE , position = &quot;raincloud&quot; , alpha = 0.6 , scale = 0.6) + scale_fill_viridis(discrete=TRUE , name = &quot;Quantile&quot; , alpha = 0.3 , option = &quot;cividis&quot;) Here is one last cool feature of ridgeline plots where we can overlap distributions within same data group. This enables us to compare distributions not only among different data groups but also within same data groups. library(vcd) data3 &lt;- Arthritis ggplot(data3) + geom_density_ridges(aes(x = Age, y = Treatment, group = interaction(Treatment,Improved),fill = Improved), alpha = 0.7) 3.4 Theory Ridgeline plots are an overlap of histograms over y-axis, and this allows us to visualize and compare overall shape of distribution among different groups. They work very well when the dataset has high number of groups to show. Also, since we are overlapping distributions, we can save space for graphs. In other words, if the number of groups to represent is too small, plotting ridgeline plots might not be an optimal choice for data visualization. On the other hand, the ridgeline plots work well when there are clear differences in distributions. Otherwise, because of overlaps, they would cause more confusion when deciphering the data. Couple points to think about before plotting the ridgeline plots: Ordering of groups will change overall shape of the plots. Figure out the optimal bin size &amp; bandwidth argument for the visualization. 3.5 External resources The below has more examples with the ridgeline plots: https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html https://cmdlinetips.com/2018/03/how-to-plot-ridgeline-plots-in-r/ "],
["maps.html", "Chapter 4 Spatial Data 4.1 Choropleth maps 4.2 Square bins 4.3 Longitude / Latitude data", " Chapter 4 Spatial Data 4.1 Choropleth maps Choropleth maps use color to indicate the value of a variable within a defined region, generally political boundaries. “Mapping in R just got a whole lot easier” by Sharon Machlis (2017-03-03) offers a tutorial on using the tmap, tmaptools, and tigris packages to create choropleth maps. Note that with this approach, you will need to merge geographic shape files with your data files, and then map. “Step-by-Step Choropleth Map in R: A case of mapping Nepal” walks through the process of creating a choropleth map using rgdal and ggplot2. (We have not followed either of these tutorials step-by-step… if you do, please provide feedback by submitting an issue). The choroplethr package makes it simple to draw choropleth maps of U.S. states, countries, and census tracts, as well as countries of the world without dealing directly with shape files. The companion package, choroplethrZip, provides data for zip code level choropleths; choroplethrAdmin1 draws choropleths for administrative regions of world countries. The following is a brief tutorial on using these packages. Note: You must install also install choroplethrMaps for choroplethr to work. In addition, choroplethr requires a number of other dependencies which should be installed automatically, but if they aren’t, you can manually install the missing packages that you are notified about when you call library(choroplethr): maptools, and rgdal, sp. We’ll use the state.x77 dataset for this example: library(tidyverse) library(choroplethr) # data frame must contain &quot;region&quot; and &quot;value&quot; columns df_illiteracy &lt;- state.x77 %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;state&quot;) %&gt;% transmute(region = tolower(`state`), value = Illiteracy) state_choropleth(df_illiteracy, title = &quot;State Illiteracy Rates, 1977&quot;, legend = &quot;Percent Illiterate&quot;) Note: the choroplethr “free course” that you may come across arrives one lesson at a time by email over an extended period so not the best option unless you have a few weeks to spare. 4.2 Square bins Packages such as statebins create choropleth style maps with equal size regions that roughly represent the location of the region, but not the size or shape. Important: Don’t install statebins from CRAN; use the dev version – it contains many improvements, which are detailed in “Statebins Reimagined”. # devtools::install_github(&quot;hrbrmstr/statebins&quot;) library(statebins) df_illit &lt;- state.x77 %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;state&quot;) %&gt;% select(state, Illiteracy) # Note: direction = 1 switches the order of the fill scale # so darker shades represent higher illiteracy rates # (The default is -1). statebins(df_illit, value_col=&quot;Illiteracy&quot;, name = &quot;%&quot;, direction = 1) + ggtitle(&quot;State Illiteracy Rates, 1977&quot;) + theme_statebins() 4.3 Longitude / Latitude data Note that the options above work with political boundaries, based on the names of the regions that you provide. Such maps require packages with geographical boundary information. Longitude / latitude data, on the other hand, can be plotted simply as a scatterplot with x = longitude and y = latitude, without any background maps (just don’t mix up x &amp; y!) The first part of “Data wrangling visualisation and spatial analysis: R Workshop” by C. Brown, D. Schoeman, A. Richardson, and B. Venables provides a detailed walkthrough of spatial exploratory data analysis with copepod data (a type of zooplankton) using this technique with ggplot2::geom_point(). If background maps are desired, there are many options. The tutorial mentioned above provides examples using the maps or sf packages. It is a highly recommended resource as it covers much of the data science pipeline from the context of the problem to obtaining data, cleaning and transforming it, exploring the data, and finally modeling and predicting. Another good choice for background maps is ggmap, which offers several different map source options. Google Maps API was the go-to, but they now require you to enable billing through Google Cloud Platorm. You get $300 in free credit, but if providing a credit card isn’t your thing, you may consider using Stamen Maps instead, with the get_stamenmap() function. Use the development version of the package; instructions and extensive examples are available on the package’s GitHub page “Getting started Stamen maps with ggmap” will help you get started with Stamen maps through an example using the Sacramento dataset in the caret package. 4.3.1 Stamen Maps and ggmaps Here is an example to get started with ggmap using get_stamenmap() to plot the longitude/latitude maps. The data for the following plots is available at https://simplemaps.com/data/us-cities. The get_stamenmap() function reqiures a bounding box, i.e the top, bottom, left and right latitude/longitude of the map you want to plot. For example, the latitude/longitude for US map are as follows: bbox &lt;- c(bottom = 25.75, top = 49 , right = -67, left = -125) You can find these values from https://www.openstreetmap.org. The other important parameters of this function are zoom and maptype. Higher the zoom level, the more detailed your plot will be. Beaware that ggmap connects to Stamen Map server to download the map, so if your bounding box is large and zoom level is high, it will have to download a lot of data and may take some time. There are differnt types of plots available via Stamen Map like terrain, watercolor, toner which can be set to maptype parameter according to your preference. You can find about avaiable options in help (?get_stamenmap). For the following examples the maptype is set to ‘toner-lite’. Let’s plot the US map. library(ggmap) usmap &lt;- get_stamenmap(bbox = bbox, zoom = 6, maptype = &#39;toner-lite&#39;) ggmap(usmap) Great! We have the US map, now let’s use the US population data to see the population density across nation. Notice that we haven’t included Alaska in the map and hence will be removing the data from Alaska. library(dplyr) df &lt;- read.csv(unz(&#39;resources/ggmap/data/uscities.zip&#39;, &#39;uscities.csv&#39;)) # Removing data of Alaska from dataset df &lt;- df %&gt;% filter(state_name != &#39;Alaska&#39;) # Population density across US using points ggmap(usmap) + geom_point(data = df, mapping = aes(x = lng, y = lat, color = population)) + ggtitle(&#39;Population density across US&#39;) This is not good! Most of the points are overlapping and thus it is not easy to interpret what’s going on here. Let’s try alpha blending. # Population density across US using points ggmap(usmap) + geom_point(data = df, mapping = aes(x = lng, y = lat, color = population), stroke= 0, alpha = 0.1) + ggtitle(&#39;Population density across US&#39;) That’s much better! We can now easily identify the areas where population density is more. You might have noticed there is no light blue dot visible on the plot. This is because it must be lying somewhere between those dense areas. One such location is New York, you can find this out by zooming the plot. We can also look at popluation density using geom_density as follows # Population density across US using Density_2d ggmap(usmap) + geom_density_2d(data = df, mapping = aes(x = lng, y = lat, color = population)) + ggtitle(&#39;Population density across US&#39;) 4.3.2 Mutilayerd plots with ggmaps We can add multiple layers to the plot as described in earlier chapters. Let’s look at the location of military stations located across US along with population density. # Location of Military units df1 &lt;- df %&gt;% filter(military == TRUE) ggmap(usmap) + geom_point(data = df, mapping = aes(x = lng, y = lat, color = population, text = city), show.legend = F, stroke= 0, alpha = 0.1) + geom_point(data = df1, mapping = aes(x = lng, y = lat , text = city), show.legend = F, color = &#39;red&#39;) + ggtitle(&#39;Military stations across US&#39;) Let’s zoom the map for state of California. # California Boundaries CAbox &lt;- c(bottom = 32.213, top = 42.163 , right = -113.95, left = -124.585) camap &lt;- get_stamenmap(bbox = CAbox, zoom = 6, maptype = &#39;toner-lite&#39;) df3 &lt;- df %&gt;% filter(state_name == &#39;California&#39;) ggmap(camap) + geom_point(data = df3, mapping = aes(x = lng, y = lat, color = population), stroke= 0, alpha = 0.1) + ggtitle(&#39;Population density for California&#39;) 4.3.3 Getting Deeper This was just a glimpse of what you can do with ggmaps using the get_stamenmap(). Note that Stamen Maps is not limited to US and can be used to plot any part of the world. If you liked this alternative to Google Maps API, I highly recommend you to check the Stamen Maps website http://maps.stamen.com for more details. "],
["workshop.html", "Chapter 5 Workshop 5.1 EDAV Community Contribution-Bookdown workshop summary", " Chapter 5 Workshop Some groups of students have contributed to the community by running the following workshops. 5.1 EDAV Community Contribution-Bookdown workshop summary Weixi Yao and Wangzhi Li This introductory workshop on bookdown is designed to give a complete guide to the bookdown package. The workshop is split into two parts. The first part covers the basic information, including what is bookdown, why use bookdown and what are the other options avaiable. The second part serves as a practice session, and each attendee will try to build their own books using the instruction we provide. If the attendees want to know more about bookdown, they can always go back to our slides for reference. We have uplodaed our complete slide to the repo (url: https://github.com/yweixi/EDAV-community-contribution.git; file name: EDAV Community Contribution.pdf). Also, all the materials we use during the workshop can be found in a seperate repo (url: https://github.com/SafeguardLi/SafeguardLi.github.io.git). "],
["cartodb-tutorial.html", "Chapter 6 CartoDB Tutorial", " Chapter 6 CartoDB Tutorial Luis Lu and Timothy Huang This tutorial gives a brief overview on getting started with CartoDB, a powerful cloud computing tool that provides geospatial analysis and mapping tools. In this tutorial, we will go over the steps of getting set up on CartoDB, uploading your first dataset, creating your first map visualization, and exploring a few of Carto’s provided geospatial data analysis tools. Link to tutorial video: https://www.youtube.com/watch?v=GxRRXWTMMe8&amp;feature=youtu.be CartoDB "],
["creating-interactive-data-visualization-using-shiny.html", "Chapter 7 Creating Interactive Data Visualization Using Shiny 7.1 Part 1 How to Build a Shiny App 7.2 1. Install the shiny package 7.3 2. Template for creating a shiny app 7.4 3. Add elements to user interface using fluidPage() 7.5 4. Build output in server instructions 7.6 5. Share your app 7.7 Part 2 How to Customize Reactions 7.8 1. Reactivity 7.9 3. Summary", " Chapter 7 Creating Interactive Data Visualization Using Shiny Duanyue Yun, Boyu Liu In this tutorial, we will use the cars dataset as an example to wall through the process of building a shiny app. The cars dataset contains various information about a particular car. cars_info &lt;- read.csv(&quot;cars.csv&quot;) 7.1 Part 1 How to Build a Shiny App 7.2 1. Install the shiny package First of all, we can install the shiny package by running the code below. install.packages(&quot;shiny&quot;) 7.3 2. Template for creating a shiny app A shiny app consists of two main components: user interface (ui) and server instructions (server). The user interface will contain the elements that a user sees on your shiny app, which can be input (possible user interactions) and output display. The server instructions will define how the app should react to a user’s action. Therefore, a basic template for creating a shiny app consists of 3 parts as shown below: library(shiny) #1 define user interface ui &lt;- fluidPage() #2 define server instructions server &lt;- function(input, output) {} #3 putting everything together shinyApp(ui = ui, server = server) 7.4 3. Add elements to user interface using fluidPage() The arguments of the fluidPage() function could be Input() functions or Output() functions. 7.4.1 Input functions Inputs define the possible ways a user can interact with our shiny App. For a numerical variable, the input could be a slider that a user can move along to select a certain value. For a categorical variable, the input could be a box where the user can select a particular category from a drop down list. All Input() functions contain 2 required arguments: inputId = and label =. inputId is for us to identify a particular input. Later we can use the same input ID in server instructions to decide the corresponding output. Therefore, to avoid errors, it is better to give a unique name to each input. label is what the user sees on the shiny App, so it should be informative. The common Input() functions supported are: actionButton(), submitButton(), checkboxInput(), checkboxGroupInput(), dateInput(), dateRangeInput(), fileInput(), numericInput(), passwordInput(), radioButtons(), selectInput(), sliderInput(), textInput(). Each Input() function has some specific arguments. For example, the sliderInput() function requires min, max arguments to set the range of the slider and also a value argument which is the default value the user sees when the shiny app is launched. You can find more about the function using ?sliderInput(). For example, we can add a select box by running the code below. ui &lt;- fluidPage( # Add a select box selectInput(inputId = &quot;varname&quot;, label = &quot;Choose a variable&quot;, choices = colnames(cars_info)[c(2, 6, 7)])) 7.4.2 Output functions We can display an output, for example a plot, by adding Output() functions to fluidPage(). Each Output() function requires one argument, which is outputId =. We will talk about how to build output in server instructions. ui &lt;- fluidPage(plotOutput(&quot;histogram&quot;)) The common Output() functions supported are: dataTableOutput(), htmlOutput(), imageOutput(), plotOutput(), tableOutput(), textOutput(), uiOutput(), verbatimTextOutput(). 7.5 4. Build output in server instructions 7.5.1 (1): Save objects you want to display to output$ server &lt;- function(input, output) { output$histogram &lt;- # code } We can use the same name in the form of a string in fluidPage() to display the output. 7.5.2 (2): Build objects with render() The render() functions that are supported include renderDataTable(), renderImage(), renderPlot(), renderPrint(), renderTable(), renderText(), renderUI(). Within render() functions, we could use {} to wrap the code so that we can write multiple lines of code to create more sophisticated output. As an example, the following code builds a histrogram of the variable mpg to our shiny app. Remember to add it to ui() to display it in the shiny app. server &lt;- function(input, output) { output$histogram &lt;- renderPlot({ hist(cars_info$mpg, main = &quot;&quot;, xlab = &quot;mpg&quot;) }) } 7.5.3 (3): Use input values with input$ When we use input$, the app will be interactive. For the following example, when the user selects a different variable, the histogram will change accordingly. server &lt;- function(input, output) { output$histogram &lt;- renderPlot({ hist(cars_info[[input$varname]], main = &quot;&quot;, xlab = input$varname) }) } 7.6 5. Share your app 7.6.1 Save your app You should save your app to one directory with every file the app needs: app.R (must be the exact file name) datasets, images, css, helper scripts, etc. 7.6.2 Publish your app on Shinyapps.io Go to https://www.shinyapps.io to sign up for an account. When you signed up for a new account on https://www.shinyapps.io, there will be instructions on how to associate your account with your RStudio IDE and how to deploy your app. 7.7 Part 2 How to Customize Reactions 7.8 1. Reactivity 7.8.1 What is reactivity? Let’s think about Microsoft Excel. In Excel, we can type some value into a cell x and type a formula that uses x into a new cell y. Then whenever we change the value in x, y’s value will change correspondingly. This is reactivity, which is also what Shiny does. Shiny has an input object input$x and an output object output$y. Any changes in input$x will cause changes in output$y. So now let’s start with reactive values, which is where reactivity starts in Shiny. 7.8.2 Reactive values Reactive values are what the user selects and depend on Input() functions. In the previous example where we create a select box, the reactive values are the variable that the user selects. Note that reactive values don’t work on their own. They actually work together with reactive functions. 7.8.3 Reactive functions (reactive toolkit) They are a kind of functions that are expected to take reactive values and know what to do with them. They are notified that they need to re-execute whenever the reactive value changes. They are included in the server instructions section to build (and rebuild) an object. We can think of reactivity in R as two-step process. Consider the following example. We use input function selectInput() to get user’s choice. input$varname is the reactive value. When we choose different variables, firstly reactive values will notify the functions which use them that they become outdated. After that its job is over and it’s time for reactive functions to do their jobs, which is rebuild the corresponding object using new values. The process is automatic in shiny. Suppose we want to output the corresponding histogram whenever the user chooses a variable. ui &lt;- fluidPage( # Add a select box selectInput(inputId = &quot;varname&quot;, label = &quot;Choose a variable&quot;, choices = colnames(cars_info)[c(2, 6, 7)]), # Add corresponding output plotOutput(outputId = &quot;histogram&quot;) ) server &lt;- function(input, output) { output$histogram &lt;- renderPlot({ hist(cars_info[[input$varname]], main = &quot;&quot;, xlab = input$varname) }) } shinyApp(ui = ui, server = server) 7.8.4 Modularize code with reactive() See the example below. When the user selects a number, the shiny app plots a histogram for that number of N(0,1) variables and also computes the summary statistics. This app has only one reactive value (number the user chooses) but has two objects, a histogram and a block of text which includes the statistics of the data. When the reactive value changes, it will notify these two objects and they will rerun the code to update themself. But the probelm is that because they rerun their code successively, so rnorm(input$num) is called twice. Since rnorm is random, each object generates a different set of values, which means the histogram describes a dataset and the summary of the statistics describes another dataset. # Before ui &lt;- fluidPage( # Add a slider sliderInput(inputId = &quot;num&quot;, label = &quot;Please choose a number.&quot;, min = 1, max = 100, value = 25), # Display the histogram plotOutput(outputId = &quot;hist&quot;), # Display the summary statistics verbatimTextOutput(&quot;stats&quot;) ) server &lt;- function(input, output) { # Build the histogram output$hist &lt;- renderPlot({hist(rnorm(input$num), main = &quot;&quot;, xlab = &quot;num&quot;)}) # Build the object that contains the summary statistics output$stats &lt;- renderPrint({summary(rnorm(input$num))}) } shinyApp(ui = ui, server = server) For example, when we only select one normal variable. It is clear that the histogram and the summary statistics do not correpond to the same data. Can the two objects describe the same data? The answer is yes! The strategy is calling rnorm(input$num) only once and saving the dataset it creates. Then use this dataset downstream when we need it. Shiny provides a function called reactive(), which can wrap a normal expression to create a reactive expression and realize what we hope to achieve. reactive(rnorm(input$num)) In this specific example, we add a code data &lt;- reactive(rnorm(input$num)) to the server and replace rnorm(input$num) in the reactive functions with data(). Note that you should call a reactive expression like a function. So here we use data() instead of data. # After ui &lt;- fluidPage( sliderInput(inputId = &quot;num&quot;, label = &quot;Please choose a number.&quot;, min = 1, max = 100, value = 25), plotOutput(outputId = &quot;hist&quot;), verbatimTextOutput(&quot;stats&quot;) ) server &lt;- function(input, output) { data &lt;- reactive(rnorm(input$num)) output$hist &lt;- renderPlot({hist(data(), main = &quot;&quot;, xlab = &quot;num&quot;)}) output$stats &lt;- renderPrint({summary(data())}) } shinyApp(ui = ui, server = server) Now when will select 1 variable, the two objects will describe the same data. 7.8.5 Prevent reactions with isolate() Sometimes we might want to delay a reactive function. For example, the following shiny app plots a scatterplot between 2 variables of the user’s choose and also allows the user to give the plot a customized title. So there are 3 inputs: the title of the scatterplot, an x variable and a y variable. With our regular code, the title will change instantaneously as the user types. # Before ui &lt;- fluidPage( textInput(inputId = &quot;title&quot;, label = &quot;Enter a title&quot;, value = &quot;displacement vs mpg&quot;), selectInput(&#39;xcol&#39;, &#39;X Variable&#39;, colnames(cars_info)[c(2, 4, 5, 6, 7)]), selectInput(&#39;ycol&#39;, &#39;Y Variable&#39;, colnames(cars_info)[c(2, 4, 5, 6, 7)], selected=colnames(cars_info)[[4]]), plotOutput(&#39;scatterplot&#39;) ) server &lt;- function(input, output) { output$scatterplot &lt;- renderPlot({ plot(cars_info[, c(input$xcol, input$ycol)], main = input$title) }) } shinyApp(ui = ui, server = server) Say we do not want the title to change until the user has chosen two variables. In this case, we can use isolate() to isolate the input title. It returns the result as a non-reactive value. That means the observed object will only react to its changes when other inputs also change. server &lt;- function(input, output) { output$scatterplot &lt;- renderPlot({ plot(cars_info[, c(input$xcol, input$ycol)], # This line isolates the input title main = isolate({input$title})) }) } 7.8.6 Trigger code with observeEvent() we can create an action button or link whose value is initially zero, and increments by one each time it is pressed. When we have an input like action button, we can trigger a response when the user clicks on the button by using observeEvent() function. Examples of an action button include download which allows the user to download a file. actionButton(inputId = &quot;download&quot;, label = &quot;Download&quot;) The observeEvent() function takes two arguments: the first argument is the reactive value(s) it responds to. In our example, it will be the action button. The second armgument is a code block which runs behind the scene whenever the input changes. observeEvent(input$download, {print(input$download)}) Here is how we can use it in our app. Every time we click the Go! button, the observer will update, which is running the block of code print(as.numeric(input$goButton). The result won’t appear in the user panel, but to appear back of our app. ui &lt;- fluidPage( actionButton(inputId = &quot;download&quot;, label = &quot;Download&quot;) ) server &lt;- function(input, output) { observeEvent(input$downloadn, { print(as.numeric(input$download)) }) } shinyApp(ui = ui, server = server) Along with observeEvent() which triggers code, there’s another function called observe(), which does the same thing and it’s a parallel of observeEvent(). But its syntax is more like render*() functions. We just give a block of code to it and it will respond to every reactive value in the code. observe({print(input$download)}) 7.8.7 Delay reactions with eventReactive() Sometimes we don’t want the outputs to change as soon as the user changes some input in the user interface. Instead, we would like to change them when the user clicks an ‘update’ button. In others words, we hope to prevent the output from updating until the user hits the button. The way to do this in Shiny is with the function eventReactive(). It creates a reactive expression that only responds to specific values, similar to reactive() but having different syntax. First we give a reactive value to it. The second argument is the code the function uses to build or rebuild the object when it’s clicked. In addition, similar to observeEvent(), the expression treats this block of code as if it has been isolated with isolate(). data &lt;- eventReactive(input$update, {rnorm(input$num)}) Let’s look at the entire code. ui &lt;- fluidPage( selectInput(inputId = &quot;varname&quot;, label = &quot;Choose a variable&quot;, choices = colnames(cars_info)[c(2, 6, 7)]), actionButton(inputId = &quot;update&quot;, label = &quot;Update&quot;), plotOutput(outputId = &quot;hist&quot;) ) server &lt;- function(input, output) { data &lt;- eventReactive(input$update, {input$varname}) output$hist &lt;- renderPlot({ hist(cars_info[[data()]], main = &quot;&quot;, xlab = data()) }) } shinyApp(ui = ui, server = server) If we choose different variable without clicking Update button, the histogram would not be updated. 7.8.8 Manage state with reactiveValues() We know that the reactive value changes whenever a user changes the input in the user panel. But we cannot set these values in our code. Fortunately, although Shiny doesn’t give us the power to overwrite the input values in our app, it gives us the power to create our own list of reactive values, which you can overwrite. reactiveValues() is a function that creates a list of reactive values to manipulate programmatically. Note that it has nothing to do with input reactive values. rv &lt;- reactiveValues(data = rnorm(100)) Let’s look at an example. If we click mpg vs displacement, the Shiny app would select column mpg and displacement from the cars_info dataset and plot a scatter plot for them. If we click mpg vs weight, it would select column mpg and weight from the cars_info dataset and plot a scatter plot for them. ui &lt;- fluidPage( actionButton(inputId = &quot;scatter1&quot;, label = &quot;mpg vs displacement&quot;), actionButton(inputId = &quot;scatter2&quot;, label = &quot;mpg vs weight&quot;), plotOutput(&quot;scatter&quot;) ) server &lt;- function(input, output) { rv1 &lt;- reactiveValues(data = cars_info[,2], label = &quot;mpg&quot;) rv2 &lt;- reactiveValues(data = cars_info[,4], label = &quot;displacement&quot;) observeEvent(input$scatter1, { rv1$data &lt;- cars_info[,2] rv1$label &lt;- &quot;mpg&quot; rv2$data &lt;- cars_info[,4] rv2$label &lt;- &quot;displacement&quot; }) observeEvent(input$scatter2, { rv1$data &lt;- cars_info[,2] rv1$label &lt;- &quot;mpg&quot; rv2$data &lt;- cars_info[,6] rv2$label &lt;- &quot;weight&quot; }) output$scatter &lt;- renderPlot({ plot(rv1$data, rv2$data, xlab = rv1$label, ylab = rv2$label)}) } shinyApp(ui = ui, server = server) 7.9 3. Summary Till now, We have learnt both syntax and usage of the basic reactive functions in Shiny. Now there are still some important tips we need to provide. We should reduce repetition when we create shiny apps. That is to place code where it will be re-run as little as necessary. Keep in mind that, Code outside the server function will be run once per R session (worker). So you only need it to run once when setting up the R session, outside the server function. For example, codes that load the help file or some library should be placed outside the server function. Code inside the server function will be run once per end user session (connection). Code inside the reactive function will be run once per reaction, which means many times. If you are interested in Shiny and would like to learn more about it, you can go to the official website or download the documentation of Shiny. The relevant resources are listed below. Official website: https://shiny.rstudio.com/ Documantation of pacakge “Shiny”: https://cran.r-project.org/web/packages/shiny/shiny.pdf Share your Shiny apps: https://www.shinyapps.io/ Shiny cheat sheet: https://shiny.rstudio.com/images/shiny-cheatsheet.pdf The main source of this tutorial is the video on the Shiny official website. We adapted it with some new examples based on the cars dataset. Hope this can help you and any suggestion is welcome. "],
["cheat-sheet.html", "Chapter 8 Cheat Sheet", " Chapter 8 Cheat Sheet Some groups of students have contributed to the community by writing the following cheat sheets. "],
["notes-of-basic-html-javascript-and-d3.html", "Chapter 9 Notes of Basic HTML, JavaScript, and D3 9.1 Leaflet Cheatsheet", " Chapter 9 Notes of Basic HTML, JavaScript, and D3 Yitao Liu (yl4343) and Yiyang Sun (ys3284) In addition to the visualization tools we have learned using R, we would like to introduce another powerful visualization tool, D3.js. We created a GitHub Page as well as the GitHub Repository to introduce basic knowledge of building a D3 visualization. We have made cheat sheets for HTML, JavaScript – two cornerstones of coding with D3 library, and a cheat sheet for D3.js. To better help fellow students to kick-off with D3 visualization, we also provided code examples of HTML and D3 in our GitHub Repository. Link to our GitHub Page: https://tonyytliu.github.io/Stat5702_CC60/ Link to our GitHub Repository: https://github.com/tonyytliu/Stat5702_CC60 9.1 Leaflet Cheatsheet Di Ye and Qiaoge Zhu This project creates a cheatsheet on leaflet package in R. link: https://drive.google.com/file/d/1NgiAYy7kaoheWbCmJRmu9NxI6Ag7s-VT/view?usp=sharing "]
]
